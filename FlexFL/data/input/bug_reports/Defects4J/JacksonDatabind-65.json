{
    "title": "<code>StdKeyDeserializer</code> can erroneously use a static factory method with more than one argument",
    "description": "\nWhile investigating an issue, I found that there was different behavior for normal deserializers and key deserializers where deserializing a value as a field works as expected, but as a map key fails with \"not a valid representation: wrong number of arguments\".\nA basic example:\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class KeyVsFieldTest {\n    @Test\n    public void deserializeAsField() throws IOException {\n        AsField as_field = new ObjectMapper().readValue(\"{\\\"name\\\": \\\"first.last\\\"}\", AsField.class);\n        assertEquals(as_field.getName()._firstname, \"first\");\n        assertEquals(as_field.getName()._lastname, \"last\");\n    }\n\n    @Test\n    public void deserializeAsKey() throws IOException {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\", new TypeReference<Map<FullName, Double>>() {\n            });\n       /* \n          Fails with: com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct Map key of type KeyVsFieldTest$FullName from String \"first.last\": not a valid representation: wrong number of arguments\n at [Source: java.io.StringReader@7113b13f; line: 1, column: 2]\n       */\n\n        Entry<FullName, Double> entry = map.entrySet().iterator().next();\n\n        assertEquals(entry.getKey()._firstname, \"first\");\n        assertEquals(entry.getKey()._lastname, \"last\");\n        assertEquals(entry.getValue().doubleValue(), 42, 0);\n    }\n\n    public static class AsField {\n        private final FullName _name;\n\n        public AsField(@JsonProperty(\"name\") FullName aName) {\n            _name = aName;\n        }\n\n        public FullName getName() {\n            return _name;\n        }\n    }\n\n    public static class FullName {\n        private final String _firstname;\n        private final String _lastname;\n\n        private FullName(String firstname, String lastname) {\n            _firstname = firstname;\n            _lastname = lastname;\n        }\n\n        @JsonCreator\n        public static FullName valueOf(String value) {\n            String[] mySplit = value.split(\"\\\\.\");\n            return new FullName(mySplit[0], mySplit[1]);\n        }\n\n        public static FullName valueOf(String firstname, String lastname) {\n            return new FullName(firstname, lastname);\n        }\n\n        @JsonValue\n        @Override\n        public String toString() {\n            return _firstname + \".\" + _lastname;\n        }\n    }\n}\nIt looks like this is because in BasicBeanDescriptor, findFactoryMethod has an incorrect assumption about the contents of _classInfo.getStaticMethods(), which will have any method named valueOf and static methods annotated with @JsonCreator:\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes)\n    {\n        // So, of all single-arg static methods:\n        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n        return null;\n    }\nThis can be worked around by annotating static factory methods not intended to be used as @JsonCreators with @JsonIgnore, due to the resolution in _classInfo.getStaticMethods(), so is not really urgent.\nPlease let me know if you have any questions about the issue!\nThanks,\nChris\n"
}