{
    "title": "Overflow in BitInputStream",
    "description": "\n\nin Class BitInputStream.java(\\src\\main\\java\\org\\apache\\commons\\compress\\utils),\nfuncion:\n public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) \n{\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) \n{\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) \n{\n                bitsCached |= (nextByte << bitsCachedSize);\n            }\n else \n{\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) \n{\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        }\n else \n{\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\nI think here \"bitsCached |= (nextByte << bitsCachedSize);\" will overflow in some cases. for example, below is a test case:\npublic static void test() {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[]\n{87, 45, 66, 15,\n                                                                      90, 29, 88, 61, 33, 74}\n);\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        try \n{\n            long ret = bin.readBits(5);\n            ret = bin.readBits(63);\n            ret = bin.readBits(12);\n        }\n catch (Exception e) \n{\n            e.printStackTrace();\n        }\n}\noverflow occur in \"bin.readBits(63);\" , so ,result in wrong result from  \"bin.readBits(12);\" \n\n"
}