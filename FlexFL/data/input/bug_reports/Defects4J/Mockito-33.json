{
    "title": "ArgumentCaptor.fromClass's return type should match a parameterized type",
    "description": "\nArgumentCaptor.fromClass's return type should match a parameterized type.  I.e. the expression ArgumentCaptor.fromClass(Class<S>) should be of type ArgumentCaptor<U> where S is a subtype of U.\nFor example:\nArgumentCaptor<Consumer<String>> captor = ArgumentCaptor.fromClass(Consumer.class)\n\ndoes not type check (i.e. it is a compile time error). It should type check.\nThe reasons that it is desirable for ArgumentCaptor.fromClass to allow expressions such as the example above to type check are:\n\nArgumentCaptor.fromClass is intended to be a convenience method to allow the user to construct an ArgumentCaptor without casting the returned value.\n\nCurrently, the user can devise a workaround such as:\nArgumentCaptor<? extends Consumer<String>> captor \n= ArgumentCaptor.fromClass(Consumer.class)\n\nThis workaround is inconvenient, and so contrary to ArgumentCaptor.fromClass being a convenience method.\n\nIt is inconsistent with @Captor, which can be applied to a field with a paramterized type.  I.e.\n\n@Captor ArgumentCaptor<Consumer<String>> captor \n\ntype checks.\n"
}