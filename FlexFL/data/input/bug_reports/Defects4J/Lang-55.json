{
    "title": "StopWatch: suspend() acts as split(), if followed by stop()",
    "description": "\n\nIn my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:\n        StopWatch sw = new StopWatch();\n        sw.start();\n        Thread.sleep(1000);\n        sw.suspend();\n        // Time 1 (ok)\n        System.out.println(sw.getTime());\n        Thread.sleep(2000);\n        // Time 1 (again, ok)\n        System.out.println(sw.getTime());\n        sw.resume();\n        Thread.sleep(3000);\n        sw.suspend();\n        // Time 2 (ok)\n        System.out.println(sw.getTime());\n        Thread.sleep(4000);\n        // Time 2 (again, ok)\n        System.out.println(sw.getTime());\n        Thread.sleep(5000);\n        sw.stop();\n        // Time 2 (should be, but is Time 3 => NOT ok)\n        System.out.println(sw.getTime());\nsuspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?\n\n"
}