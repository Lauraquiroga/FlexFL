{
    "title": "ArrayIndexOutOfBoundsException when doing multiple reads() on encoding Base64InputStream",
    "description": "\n\nWhen encoding a sizable stream byte by byte (so, just calling Base64InputStream.read()), after 10920 successful read()s, this happens: \njava.lang.ArrayIndexOutOfBoundsException: 2\n        at org.apache.commons.codec.binary.Base64.encode(Base64.java:502)\n        at org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:157)\n        at org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)\nBased on this, the necessary conditions seem to be that buffer = null and modulus = 2. Then, if a read() is done, a single-byte buffer is used, whose length is doubled by resizeBuffer(), but that still doesn't make it big enough to hold the 4 bytes written to it because modulus was just incremented to 0. \nHere's some sample code:\nimport org.apache.commons.codec.binary.Base64InputStream;\npublic class TestReads {\n    public static void main(String[] args) {\n        Base64InputStream b64stream = new Base64InputStream(System.in, true, 0, null);\n        int n = 0;\n        try \n{\n            while (b64stream.read() != -1) n++;\n        }\n catch (Exception x) \n{\n            System.out.println(n);\n            x.printStackTrace();\n        }\n    }\n}\n\n"
}