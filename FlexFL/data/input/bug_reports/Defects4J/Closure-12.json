{
    "title": "Try/catch blocks incorporate code not inside original blocks",
    "description": "What steps will reproduce the problem?\n\r\nStarting with this code:\r\n\r\n-----\r\nfunction a() {\r\n var x = '1';\r\n try {\r\n  x += somefunction();\r\n } catch(e) {\r\n }\r\n x += \"2\";\r\n try {\r\n  x += somefunction();\r\n } catch(e) {\r\n }\r\n document.write(x);\r\n}\r\n\r\na();\r\na();\r\n-----\r\n\r\nIt gets compiled to:\r\n\r\n-----\r\nfunction b() {\r\n  var a;\r\n  try {\r\n    a = \"1\" + somefunction()\r\n  }catch(c) {\r\n  }\r\n  try {\r\n    a = a + \"2\" + somefunction()\r\n  }catch(d) {\r\n  }\r\n  document.write(a)\r\n}\r\nb();\r\nb();\r\n-----\r\n\r\nWhat is the expected output? What do you see instead?\n\r\nThe problem is that it's including the constant \"1\" and \"2\" inside the try block when the shouldn't be. When executed uncompiled, the script prints \"1212\". When compiled, the script prints \"undefinedundefined\".\r\n\r\nThis behavior doesn't happen if the entire function gets inlined, or if the code between the two try blocks is sufficiently complex.\r\n\r\n\r\nWhat version of the product are you using? On what operating system?\n\r\nClosure Compiler (http://code.google.com/closure/compiler)\r\nVersion: 20120430 (revision 1918)\r\nBuilt on: 2012/04/30 18:02\r\njava version \"1.6.0_33\"\r\nJava(TM) SE Runtime Environment (build 1.6.0_33-b03-424-11M3720)\r\nJava HotSpot(TM) 64-Bit Server VM (build 20.8-b03-424, mixed mode)\r\n"
}