{
    "title": "Some multi-iterator parsing peek sequences incorrectly consume elements",
    "description": "\n\nRepeated calls to CSVParser Iterable return new Iterators that each reference the same underlying parser lexer. Within the scope of a\u00a0single Iterator, row peeking with Iterator.hasNext() works as intended. When row peeking with Iterator.hasNext()\u00a0under circumstances that create a new Iterator, an element is consumed by the iterator which cannot be\u00a0accessed by subsequent, newly created Iterators and Iterator.next()s. Effectively, the record Iterator and the lexer get out of sequence. See snippet below.\nThe \"right thing\" is keeping the Iterator in sequence with the lexer, and since this is reading from a buffer, there seem to me to be only two resolutions:\n\nOne lexer, one Iterator.\nNew Iterators, but peeking with hasNext doesn't advance the lexer.\n\n\u00a0\nIf there's a consensus on one of these, I can put up a PR.\n\u00a0\n\n\r\n\u00a0 @Test\r\n\r\n\u00a0 public void newIteratorSameLexer() throws Exception {\r\n\r\n\r\n\r\n\u00a0 \u00a0 String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"Enhanced for loop, no peeking:\");\r\n\r\n\u00a0 \u00a0 CSVParser parser =\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 int recordNumber = 0;\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but the lexer isn't reset so we can pick up\r\n\r\n\u00a0 \u00a0 // where we left off.\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Enhanced for loop, no peeking:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // 3 -> 3\r\n\r\n\u00a0 \u00a0 // 4 -> 4\r\n\r\n\u00a0 \u00a0 // 5 -> 5\r\n\r\n\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"\\nEnhanced for loop, with peek:\");\r\n\r\n\u00a0 \u00a0 parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 recordNumber = 0;\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but we call hasNext before next, so we queue\r\n\r\n\u00a0 \u00a0 // one element for consumption. This element is discarded by the new iterator, even though the\r\n\r\n\u00a0 \u00a0 // lexer has advanced a row, so we've consumed an element with the peek!\r\n\r\n\u00a0 \u00a0 System.out.println(\"hasNext(): \" + parser.iterator().hasNext());\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Enhanced for loop, with peek:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // hasNext(): true\r\n\r\n\u00a0 \u00a0 // 3 -> 4\r\n\r\n\u00a0 \u00a0 // 4 -> 5\r\n\r\n\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"\\nIterator while, with peek:\");\r\n\r\n\u00a0 \u00a0 parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 recordNumber = 0;\r\n\r\n\u00a0 \u00a0 Iterator<CSVRecord> iter = parser.iterator();\r\n\r\n\u00a0 \u00a0 while (iter.hasNext()) {\r\n\r\n\u00a0 \u00a0 \u00a0 CSVRecord record = iter.next();\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // When we use the same iterator, iterator and lexer are in sequence.\r\n\r\n\u00a0 \u00a0 System.out.println(\"hasNext(): \" + iter.hasNext());\r\n\r\n\u00a0 \u00a0 while (iter.hasNext()) {\r\n\r\n\u00a0 \u00a0 \u00a0 CSVRecord record = iter.next();\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Iterator while, with peek:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // hasNext(): true\r\n\r\n\u00a0 \u00a0 // 3 -> 3\r\n\r\n\u00a0 \u00a0 // 4 -> 4\r\n\r\n\u00a0 \u00a0 // 5 -> 5\r\n\r\n\u00a0 }\n\n\n"
}