{
    "title": "Missing properties when deserializing using a builder class with a non-default constructor and a mutator annotated with <code>@JsonUnwrapped</code>",
    "description": "\nWhen deserializing using a builder class with a non-default constructor and any number of mutator methods annotated with @JsonUnwrapped, the BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped method cuts short the process of adding SettableBeanProperties.\nThe logic dictates that once all properties necessary to construct the builder have been found, the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process.\nTherefore, in the case that the builder has a single property required for construction, and that property is found anywhere other than at the end of the JSON content, any properties subsequent to the constructor property are not evaluated and are left with their default values.\nGiven the following classes:\n@JsonDeserialize(builder = Employee.Builder.class)\npublic class Employee {\n    private final long id;\n    private final Name name;\n    private final int age;\n\n    private Employee(Builder builder) {\n        id = builder.id;\n        name = builder.name;\n        age = builder.age;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Name getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    @JsonPOJOBuilder(withPrefix = \"set\")\n    public static class Builder {\n        private final long id;\n        private Name name;\n        private int age;\n\n        @JsonCreator\n        public Builder(@JsonProperty(\"emp_id\") long id) {\n            this.id = id;\n        }\n\n        @JsonUnwrapped\n        public void setName(Name name) {\n            this.name = name;\n        }\n\n        @JsonProperty(\"emp_age\")\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        public Employee build() {\n            return new Employee(this);\n        }\n    }\n}\n\npublic class Name {\n    private final String first;\n    private final String last;\n\n    @JsonCreator\n    public Name(\n        @JsonProperty(\"emp_first_name\") String first,\n        @JsonProperty(\"emp_last_name\") String last\n    ) {\n        this.first = first;\n        this.last = last;\n    }\n\n    public String getFirst() {\n        return first;\n    }\n\n    public String getLast() {\n        return last;\n    }\n}\nAnd given the following JSON string:\n{\n    \"emp_age\": 30,\n    \"emp_id\": 1234,\n    \"emp_first_name\": \"John\",\n    \"emp_last_name\": \"Doe\"\n}\nWe will see the following output:\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\n\nSystem.out.println(emp.getAge()); // 30\nSystem.out.println(emp.getId()); // 1234\nSystem.out.println(emp.getName()); // null\nHowever, if we place the emp_id property at the end of the JSON string, we would get the following output:\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\n\nSystem.out.println(emp.getAge()); // 30\nSystem.out.println(emp.getId()); // 1234\nSystem.out.println(emp.getName()); // Name Object\nIf we were to place emp_age and emp_first_name and emp_last_name all after the emp_id property in the JSON string, we would get the following output:\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\n\nSystem.out.println(emp.getAge()); // 0\nSystem.out.println(emp.getId()); // 1234\nSystem.out.println(emp.getName()); // null\n"
}