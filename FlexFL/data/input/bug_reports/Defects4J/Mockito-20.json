{
    "title": "Allow convenient spying on abstract classes",
    "description": "\nI posted this in GoogleCode and was asked to submit in github.\nMockito is easy to use when the test needs to provide canned values for a certain method.\nBut it gets harder when a canned value isn't sufficient.\nExample 1: Fake with trivial Logic\ninterface UserAccount {\n  List<String> getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\n\nWhen mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\nExample 2: callback-style API\ninterface AccountService {\n  void getAccount(String id, AsyncCallback<UserAccount> callback);\n}\n\nStubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\nwhen(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n  AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n  ...\n});\n\nExample 3: Uninteresting parameters\ninterface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\n\nNone of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\nIf AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\nwhen(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);\nAnd all other parameters are required to be wrapped in eq().\nProposal\nI propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\nFor example 1\nabstract class FakeUserAccount implements UserAccount {\n  private final List<String> emails = new ArrayList<>();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List<String> getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n\nFor example 2\nabstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);\n\nFor example 3\nabstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future<Account> getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future<Account> getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(\"id\")).thenReturn(...);\n\nMy work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\nBut because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\nIf the idea sounds okay to give a try, I'll volunteer to submit a patch.\nThanks!\n"
}