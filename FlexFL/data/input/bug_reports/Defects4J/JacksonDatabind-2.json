{
    "title": "Unwanted POJO's embedded in tree via serialization to tree",
    "description": "\nI have a class, more or less:\n   class X<T> {\n       String s;\n       List<T> items;\n  };\n\nIt has a custom serializer.\nWhen I serialize to a tree, the entire list ends up as a\nVALUE_EMBEDDED_OBJECT: the ArrayList itself.\nHere's the serializer class, note the use of writeObjectField.\npublic class ListAttributeSerializer extends JsonSerializer<ListAttribute> {\n    @Override\n    public void serialize(ListAttribute value, JsonGenerator jgen,\nSerializerProvider provider) throws IOException {\n        jgen.writeStartObject();\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        jgen.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(ListAttribute value, JsonGenerator\njgen, SerializerProvider provider, TypeSerializer typeSer) throws\nIOException {\n        typeSer.writeTypePrefixForObject(value, jgen);\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        typeSer.writeTypeSuffixForObject(value, jgen);\n}\n}\n\nAnd Tatu wrote me:\nOk. valueToTree() uses TokenBuffer as target, so it probably then simply retains Object passed as-is, to defer conversion/serialization, for common use case of buffering. But in your case you would rather get actual serialization into JsonNodes.\nYou will probably want to write conversion out then, something like:\nbyte[] json = mapper.writeValueAsBytes(referenceText);\nJsonNode tree = mapper.readTree(json);\nThis is just the work-around on short term.\nBut this is one thing where configurability might be needed; or possibly different methods. One that forces full serialization into JSON with no POJONodes, other that leaves things as is.\n"
}