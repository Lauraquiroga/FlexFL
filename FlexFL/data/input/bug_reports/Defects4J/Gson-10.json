{
    "title": "JsonAdapter annotation ignored for primitive fields",
    "description": "\nReflectiveTypeAdapterFactory correctly detects the @JsonAdapter annotation and registers the custom adapter (source), but its write method wraps that type adapter in a TypeAdapterRuntimeTypeWrapper (source), which overrides the adapter with the default Gson adapter (source).\nHere's a test that demonstrates the behavior:\ndiff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest\nindex 4c745ec..8cae980 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n@@ -220,4 +220,43 @@ public final class JsonAdapterAnnotationOnFieldsTest extends TestCase {\n       this.part = part;\n     }\n   }\n+\n+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithPrimitivePart(42));\n+    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n+    assertEquals(42, gadget.part);\n+  }\n+\n+  private static final class GadgetWithPrimitivePart {\n+    @JsonAdapter(LongToStringTypeAdapterFactory.class)\n+    final long part;\n+\n+    private GadgetWithPrimitivePart(long part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {\n+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {\n+      @Override public void write(JsonWriter out, Long value) throws IOException {\n+        out.value(value.toString());\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      @Override public Long read(JsonReader in) throws IOException {\n+        return in.nextLong();\n+      }\n+    };\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      Class<?> cls = type.getRawType();\n+      if (Long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      } else if (long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      }\n+      throw new IllegalStateException(\"Non-long field of type \" + type\n+          + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n+    }\n+  }\n }\nAnd here's the result of running it:\n[snip]\nRunning com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest\nTests run: 8, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec <<< FAILURE!\n[snip]\nResults :\n\nFailed tests:   testPrimitiveFieldAnnotationTakesPrecedenceOverDefault(com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest): expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}>\n\nTests run: 990, Failures: 1, Errors: 0, Skipped: 0\n\nIs this the intended behavior? If so, JsonAdapter's documentation is a bit misleading.\nIf it's not, I unfortunately do not have a suggested fix. I was actually a bit surprised to see that a new TypeAdapterRuntimeTypeWrapper object is constructed for each field that is serialized, on every serialization.\nIn case you would like to incorporate my test into Gson, I hereby assign copyright of that test to Google.\nThanks!\n"
}