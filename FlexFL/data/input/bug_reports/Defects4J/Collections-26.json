{
    "title": "MultiKey subclassing has deserialization problem since COLLECTIONS-266: either declare protected readResolve() or MultiKey must be final",
    "description": "\n\nMultiKey from collections 4 provides a transient hashCode and a private readResolve to resolve COLLECTIONS-266: Issue with MultiKey when serialized/deserialized via RMI.\nUnfortunately the solution does not work in case of subclassing: readResolve in MultiKey should be declared protected readResolve() to be called during deserialization of the subclass. Otherwise MultiKey must be final to avoid such subclassing.\nTestcase:\nMultiKeySerializationTest.java\npackage de.ivu.test.common.collections4;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.apache.commons.collections4.keyvalue.MultiKey;\nimport org.junit.Test;\n\npublic class MultiKeySerializationTest {\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReadResolveEqualHashCode()\n            throws IOException, ClassNotFoundException {\n        class MultiKey2<A, B>\n                extends MultiKey {\n\n            private static final long serialVersionUID = 1928896152249821416L;\n\n            public MultiKey2(A key1, B key2) {\n                super(key1, key2);\n            }\n\n            public A getFirst() {\n                return (A) getKey(0);\n            }\n\n            public B getSecond() {\n                return (B) getKey(1);\n            }\n            \n            // FIXME: MultiKey should either declare protected readResolve() or must be final.\n        }\n        MultiKey2<String, String> one = new MultiKey2<>(\"bla\", \"blub\");\n        System.out.println(one.hashCode());\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(byteOut);\n        out.writeObject(one);\n        out.close();\n        byte[] serialized = byteOut.toByteArray();\n        ByteArrayInputStream byteIn = new ByteArrayInputStream(serialized);\n        ObjectInputStream in = new ObjectInputStream(byteIn);\n        MultiKey2<String, String> two = (MultiKey2<String, String>) in.readObject();\n        System.out.println(two.hashCode());\n        assertEquals(\"hashCode must be equal - please check for protected readResolve in MultiKey*\", one.hashCode(),\n            two.hashCode());\n    }\n}\n\n\nFix:\nMultiKey.java\n@@ -274,7 +274,7 @@\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+    protected Object readResolve() {\n         calculateHashCode(keys);\n         return this;\n     }\n\n\n\n"
}