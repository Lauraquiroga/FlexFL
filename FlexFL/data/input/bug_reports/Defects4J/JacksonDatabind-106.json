{
    "title": "<code>TreeTraversingParser</code> does not check int bounds",
    "description": "\nSimilar to #1729, TreeTraversingParser does not perform bounds checks on some JSON values bound to ints.\nUsing Jackson version 2.9.7, here are several comparisons generated with the following code:\n  public static class IntClass {\n    public int x;\n\n    @Override\n    public String toString() {\n      return String.valueOf(x);\n    }\n  }\n\n  ObjectMapper mapper  = new ObjectMapper();\n  void readAndPrint(String _example) {\n    String fromTree;\n    try {\n      JsonNode tree = mapper.readTree(_example);\n      fromTree = mapper.readerFor(IntClass.class).readValue(tree).toString();\n    } catch (IOException _e) {\n      fromTree = _e.getClass().getSimpleName();\n    }\n\n    String fromString;\n    try {\n      fromString = mapper.readerFor(IntClass.class).readValue(_example).toString();\n    } catch (IOException _e) {\n      fromString = _e.getClass().getSimpleName();\n    }\n\n    System.out.printf(\"|%30s | %30s | %-30s|\\n\", _example, fromTree, fromString);\n  }\n\n  @Test\n  public void compareFromTree() {\n    System.out.printf(\"|%30s | %30s | %-30s|\\n\", \"json input\", \"read from tree\", \"read from string\");\n    System.out.println(\"|-------------------------------|--------------------------------|-------------------------------|\");\n    readAndPrint(\"{\\\"x\\\": 0}\");\n    // etc.\n  }\n\n\n\njson input\nread from tree\nread from string\n\n\n\n\n{\"x\": 0}\n0\n0\n\n\n{\"x\": 10}\n10\n10\n\n\n{\"x\": 1e4}\n10000\n10000\n\n\n{\"x\": 1e10}\n2147483647\nJsonMappingException\n\n\n{\"x\": 1e-1}\n0\n0\n\n\n{\"x\": 2147483648}\n-2147483648\nJsonMappingException\n\n\n{\"x\": 2147483649}\n-2147483647\nJsonMappingException\n\n\n{\"x\": -2147483649}\n2147483647\nJsonMappingException\n\n\n{\"x\": -4294967295}\n1\nJsonMappingException\n\n\n{\"x\": 0.1}\n0\n0\n\n\n{\"x\": 1.9}\n1\n1\n\n\n{\"x\": 1.9999999999999999}\n2\n2\n\n\n{\"x\": true}\nMismatchedInputException\nMismatchedInputException\n\n\n{\"x\": {}}\nMismatchedInputException\nMismatchedInputException\n\n\n{\"x\": []}\nMismatchedInputException\nMismatchedInputException\n\n\n{\"x\": [0]}\nMismatchedInputException\nMismatchedInputException\n\n\n{\"x\": \"0\"}\n0\n0\n\n\n{\"x\": \"10\"}\n10\n10\n\n\n{\"x\": \"1e4\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"1e10\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"1e-1\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"2147483648\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"2147483649\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"-2147483649\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"-4294967295\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"0.1\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"1.9\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"1.9999999999999999\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"true\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"{}\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"[]\"}\nInvalidFormatException\nInvalidFormatException\n\n\n{\"x\": \"[0]\"}\nInvalidFormatException\nInvalidFormatException\n\n\n\nWithout digging further into the code, it appears if the JSON value is numeric, TreeTraversingParser silently overflows. Maybe this is expected behavior, but to me the inconsistency between reading from a non-tree (reader/string/file, etc) versus directly from a tree seems like a bug. At the very least, it makes it less convenient to do manipulations on a JSON document before binding.\nI would expect an exception thrown for the all but the first three examples above, but I do understand there are use-cases for coercing values. Even so, I would expect the coercion logic to be\n\nconsistent between the parsers (or clearly documented otherwise)\nconsistent between quoted and unquoted values\n\nI'm also curious about the expected behavior when converting non-integral values. Why is true MismatchedInput, but 0.1 is converted? Similarly, why are 0.1, 1e4, and 1e-1 acceptable, but not when in quotes, even though \"10\" and other quote integers are acceptable?\nThanks for all your hard work on this. I hope this issue doesn't come off as condescending. For our specific use case, we read the value as a tree, validating it against a schema, then using Jackson to bind the tree to an object. While it's true that we can specify type, minimum, and maximum values in the schema, it is prone to mistakes, and there's not necessarily a reason to tie the schema to the language implementation, provided things like overflow consistently result in an exception. Thus, I'm trying to better understand the expectations and limits Jackson has when using the tree parser.\n"
}