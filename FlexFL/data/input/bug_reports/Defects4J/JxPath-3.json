{
    "title": "StackOverflow error on a call to 'JXPathContext.createPath()'",
    "description": "\n\nI'm running into a StackOverflow error on a call to\n'JXPathContext.createPath()' whenever I have a path that looks like\n'a/b[1]/c'.  I took a quick look at the code and it appears JXPath, when\ntrying to create its parent pointer, simply recreates an equivalent\npointer(???).\nHere is code to reproduce the problem.\n    Map map = new HashMap();\n    map.put(\"a\", null);\n    JXPathContext pathContext = JXPathContext.newContext(map);\n    pathContext.setFactory(new AbstractFactory() {\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, String\nname, int index) {\n        Map parentMap = (Map)parent;\n        System.out.println(parent + \":\" + name + \":\" + index);\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) \n{\n            list = new ArrayList();\n          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) {\n            list.add(i, null);\n          }\n          parentMap.put(name, list);\n        } else {\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\n\n    });\n    pathContext.createPath(\"a/b[1]/c\");\n\n***************\n\nI have continued looking into this, and found that the problem is that, if\nthe List is created with a 'null' element, JXPath gets stuck in infinite\nrecursion.\n\nTo discover this, I changed my Factory to implement the following method:\n\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, \n          String name, int index) {\n\n        if (pointer instanceof NodePointer) {\n          index = ((NodePointer)pointer).getIndex();\n        }\n        System.out.println(parent + \":\" + name + \":\" + index);\n        Map parentMap = (Map)parent;\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) {            list = new ArrayList();          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) \n{\n            list.add(i, new HashMap());  // !!!!!!  Don't set to 'null'\n          }\n          parentMap.put(name, list);\n        } else \n{\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\nThen I ran the following code:\n    pathContext.createPath(\"a/b[1]/c\");\n    pathContext.createPath(\"a/b[2]/c\");  // STACK OVERFLOW HERE\nHere is the stack trace at the beginning, where\n'ValueUtils.expandCollection()' is called.  It puts 'null' into the list,\nthus causing the stack overflow as we cycle between createPath() &\ncreateChild().\nThread [main] (Suspended (breakpoint at line 227 in DynamicPropertyPointer))\n\tDynamicPropertyPointer.createPath(JXPathContext) line: 227\n\tDynamicPropertyPointer(PropertyPointer).createChild(JXPathContext,\nQName, int) line: 188\n\tNullElementPointer.createPath(JXPathContext) line: 82\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tJXPathContextReferenceImpl.createPath(String, Expression) line: 447\n\tJXPathContextReferenceImpl.createPath(String) line: 427\n\tTest.test4() line: 75\n\tTest.main(String[]) line: 38\n\n"
}