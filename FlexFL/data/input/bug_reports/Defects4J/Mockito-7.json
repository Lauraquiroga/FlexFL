{
    "title": "Deep stubbing with generic responses in the call chain is not working",
    "description": "\nDeep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock myMock1 that provides a function that returns a generic T. If T also has a function that returns a generic, an Exception with the message \"Raw extraction not supported for : 'null'\" will be thrown.\nAs an example the following test will throw an Exception:\npublic class MockitoGenericsDeepStubTest {\n\n    @Test\n    public void discoverDeepMockingOfGenerics() {\n        MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\n\n        when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n    }\n\n    public static interface MyClass1 <MC2 extends MyClass2> {\n        public MC2 getNested();\n    }\n\n    public static interface MyClass2<MC3 extends MyClass3> {\n        public MC3 getNested();\n    }\n\n    public static interface MyClass3 {\n        public String returnSomething();\n    }\n}\nYou can make this test run if you step into the class ReturnsDeepStubs and change the method withSettingsUsing to return MockSettings with ReturnsDeepStubs instead of ReturnsDeepStubsSerializationFallback as default answer:\nprivate MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n    MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n            withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n            : withSettings();\n\n    return propagateSerializationSettings(mockSettings, parentMockSettings)\n            .defaultAnswer(this);\n}\nHowever, this breaks other tests and features.\nI think, the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is \"closed\" at this point.\nThanks and kind regards\nTobias\n"
}