{
    "title": "does not properly handle NodeSet returned by extension function",
    "description": "\n\nPer the documentation, my function is returning a BasicNodeSet containing zero\nor more pointers:\n  public static NodeSet observations(ExpressionContext context) {\n    // the cast below shouldn't break, as this is the only pointer type that\n    // makes sense in this context\n    List<NodePointer> ptrs = extractObservations(\n                                  (NodePointer)context.getContextNodePointer(), \n                                  new ArrayList<NodePointer>());\n    BasicNodeSet result = new BasicNodeSet();\n    for (NodePointer ptr : ptrs) \n{\n      result.add(ptr);\n    }\n    return result;\n  }\nHowever, if I call JXPathContext.selectNodes(\"ems:observations()\"), I'm getting\na single node containing the BasicNodeSet. I notice that there is a testcase for\nfunctions that return NodeSets, but that it uses expressions that actually\nreturn the children of the NodeSet (\"test:nodeSet()/name\").\nThere appear to be two problems. First, Expression.iterate() and\nExpression.iteratePointers() do not correctly recognize a NodeSet as something\niterable. I've resolved this by reaching into the NodeSet and getting an\niterator over its pointers.\nSecond, Expression.PointerIterator doesn't recognize when it already has a\npointer, and instead tries to wrap it in a new pointer. This ends up treating\nthe pointer as a bean.\nI've made these changes, and written a testcase that uses an unadorned NodeSet\nfunction. I also found a class that used a variable named \"enum\", and changed\nthis so that it would compile under 1.5.\nThe patch is attached. It's relative to \"commons-jxpath-1.2\" (root of extract\ndirectory).\n\n"
}